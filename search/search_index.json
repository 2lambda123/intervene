{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hassle free HTTP(S) API proxying for development Quickly mock endpoints in HTTP(S) APIs, edit requests and responses, proxy everything else to your real API. Feature summary \ud83d\udd17 Respond to specific endpoints with JSON responses, proxy everything else to your real server Alter requests and/or responses before/after proxying to your real server Config file can be as simple as an endpoint and some JSON to return Automatic CORS support Automatic HTTPS support (self-signed certificate generation and trusting the certificate for chrome & safari) Example \ud83d\udd17 Let's say you've got a website that accesses your API at https://mycompany.com/api. There's a GET /api/cat that returns some JSON information ( name , color , image ) about a cat. You're planning a major update in the backend to add GET /api/dog . It's going to take the backend developers a few days to get that implemented, but you want to start work on the frontend already. Run this on the command line (Mac or Linux) intervene create https://mycompany.com It's going to ask for admin privileges because it needs to override some things. It creates a file called mycompany.com.ts , which is an intervene config. Leave the process running and open the file. import { ProxyConfig , routeBuilder } from '/Users/foo/Library/node_modules/intervene' ; const config : ProxyConfig = { target : 'https://mycompany.com' , routes : { // Some example configurations follow // ... } }; export default config ; (Don't worry about path in the import statement. It's going to depend on how you installed intervene , but intervene is smart enough to fix this path dynamically when loading the config file) You should see the site still works as normal (in chrome at least, you'll get a certificate warning in Firefox which you'll need to accept). GET /api/cat still responds the same. Now let's change the configuration to include a new route: const config : ProxyConfig = { target : 'https://mycompany.com' , routes : { '/api/dog' : { name : 'Fido' , color : 'Beige' , image : 'https://dogimages.com/bestdog.jpg' } } }; Save the file (no need to restart the intervene process, it will notice and restart itself. Now, if you curl -k https://mycompany.com/api/dog , you'll get the JSON specified in the file. curl -k https://mycompany.com/api/cat still responds the same, because it proxies through to the real https://mycompany.com . Altering responses \ud83d\udd17 Another update is planned to also return the age of the cat. You don't want to mock the whole endpoint, you just want to add the age property to whatever the real backend returns. Let's make a method endpoint. const config : ProxyConfig = { target : 'https://mycompany.com' , routes : { '/api/dog' : { name : 'Fido' , color : 'Beige' , image : 'https://dogimages.com/bestdog.jpg' }, '/api/cat' : async ( req , h , proxy ) => { const response = await proxy (); response . body . age = 7 ; return response ; } } }; Save the file again, and the https://mycompany.com/api/cat endpoint now has an added age property, with the rest of the response exactly as returned by the real server. More options \ud83d\udd17 You can also change the request before it's proxied, including PUT/POST bodies, add/remove/change request and response headers, change the status code, respond with invalid responses, delay responses etc etc. There's also the option to build types around the request and response bodies, which can be a nice way to document an interface as you're working with a mock of the data. Supported OS \ud83d\udd17 intervene supports macOS and Linux. Windows is not yet supported. Installation \ud83d\udd17 You need at least node 8 npm install -g intervene Example route configurations \ud83d\udd17 Return a simple JSON response for /users/<anything> '/users/{userId}' : { fixed : true , jsonResponse : true , here : 'can go anything' } Example request / response GET /users/123456 HTTP/1.1 200 OK content-type: application-json; charset=utf-8 { \"fixed\": true, \"jsonResponse\": true, \"here\": \"can go anything\" } Return a simple string '/fixedresponse' : 'plain text response' , This returns a simple plain text response Proxy a call and mutate the response '/tweets' : async ( req , h , proxy ) => { // Call the target const realResponse = await proxy (); // Mutate the response // `body` contains the JSON from the response. Mutating it will mutate the response provided if ( realResponse . body && realResponse . body . collection ) { // Strip everything but the first item in the collection realResponse . body . collection . splice ( 1 , realResponse . body . collection . length ) } // And return it return realResponse ; } The calls the target, then mutates the response object, returning the mutated response. Modifying the request before proxying, then modifying the response 'POST /api/{path*}' : async ( req , h , proxy ) => { // Edit the request URL before proxying // (req.params is an object containing the path params, in this case `path`) req . url . pathname = '/api/v1/' + req . params . path ; // `req.payload` is the POST request payload (when JSON). Altering the object alters what gets proxied // You can also access `req.textPayload` to alter it as a string, or `req.rawPayload` to alter it as a buffer. // Whichever property is set last takes precedence - for instance, setting `req.textPayload = 'replaced'` after this // will overwrite the paylod with the string `replaced` req . payload . apiVersion = 2 ; // Edit the request headers before proxying // Incoming request headers are all lowercased req . headers [ 'x-replaced-header' ] = 'new or updated value' ; // Actually proxy the request const res = await proxy (); // Edit the response headers after proxying res . headers [ 'x-response-header' ] = 'new or updated value' ; // Return the response return res ; }, Construct a custom response 'PUT /api/mockme' : ( req , h , proxy ) => { // Return a custom response with a custom status code and headers // assuming called with `?arg=xxxx` const result = { some : { json : 4 , queryArg : req . url . query . arg } }; // The `h` variable is the Hapi response toolkit const response = h . response ( result ); response . header ( 'x-response-header' , 'new value' ); response . code ( 202 ); response . type ( 'application/json' ); return response ; }","title":"Welcome"},{"location":"#feature-summary","text":"Respond to specific endpoints with JSON responses, proxy everything else to your real server Alter requests and/or responses before/after proxying to your real server Config file can be as simple as an endpoint and some JSON to return Automatic CORS support Automatic HTTPS support (self-signed certificate generation and trusting the certificate for chrome & safari)","title":"Feature summary"},{"location":"#example","text":"Let's say you've got a website that accesses your API at https://mycompany.com/api. There's a GET /api/cat that returns some JSON information ( name , color , image ) about a cat. You're planning a major update in the backend to add GET /api/dog . It's going to take the backend developers a few days to get that implemented, but you want to start work on the frontend already. Run this on the command line (Mac or Linux) intervene create https://mycompany.com It's going to ask for admin privileges because it needs to override some things. It creates a file called mycompany.com.ts , which is an intervene config. Leave the process running and open the file. import { ProxyConfig , routeBuilder } from '/Users/foo/Library/node_modules/intervene' ; const config : ProxyConfig = { target : 'https://mycompany.com' , routes : { // Some example configurations follow // ... } }; export default config ; (Don't worry about path in the import statement. It's going to depend on how you installed intervene , but intervene is smart enough to fix this path dynamically when loading the config file) You should see the site still works as normal (in chrome at least, you'll get a certificate warning in Firefox which you'll need to accept). GET /api/cat still responds the same. Now let's change the configuration to include a new route: const config : ProxyConfig = { target : 'https://mycompany.com' , routes : { '/api/dog' : { name : 'Fido' , color : 'Beige' , image : 'https://dogimages.com/bestdog.jpg' } } }; Save the file (no need to restart the intervene process, it will notice and restart itself. Now, if you curl -k https://mycompany.com/api/dog , you'll get the JSON specified in the file. curl -k https://mycompany.com/api/cat still responds the same, because it proxies through to the real https://mycompany.com .","title":"Example"},{"location":"#altering-responses","text":"Another update is planned to also return the age of the cat. You don't want to mock the whole endpoint, you just want to add the age property to whatever the real backend returns. Let's make a method endpoint. const config : ProxyConfig = { target : 'https://mycompany.com' , routes : { '/api/dog' : { name : 'Fido' , color : 'Beige' , image : 'https://dogimages.com/bestdog.jpg' }, '/api/cat' : async ( req , h , proxy ) => { const response = await proxy (); response . body . age = 7 ; return response ; } } }; Save the file again, and the https://mycompany.com/api/cat endpoint now has an added age property, with the rest of the response exactly as returned by the real server.","title":"Altering responses"},{"location":"#more-options","text":"You can also change the request before it's proxied, including PUT/POST bodies, add/remove/change request and response headers, change the status code, respond with invalid responses, delay responses etc etc. There's also the option to build types around the request and response bodies, which can be a nice way to document an interface as you're working with a mock of the data.","title":"More options"},{"location":"#supported-os","text":"intervene supports macOS and Linux. Windows is not yet supported.","title":"Supported OS"},{"location":"#installation","text":"You need at least node 8 npm install -g intervene","title":"Installation"},{"location":"#example-route-configurations","text":"Return a simple JSON response for /users/<anything> '/users/{userId}' : { fixed : true , jsonResponse : true , here : 'can go anything' } Example request / response GET /users/123456 HTTP/1.1 200 OK content-type: application-json; charset=utf-8 { \"fixed\": true, \"jsonResponse\": true, \"here\": \"can go anything\" } Return a simple string '/fixedresponse' : 'plain text response' , This returns a simple plain text response Proxy a call and mutate the response '/tweets' : async ( req , h , proxy ) => { // Call the target const realResponse = await proxy (); // Mutate the response // `body` contains the JSON from the response. Mutating it will mutate the response provided if ( realResponse . body && realResponse . body . collection ) { // Strip everything but the first item in the collection realResponse . body . collection . splice ( 1 , realResponse . body . collection . length ) } // And return it return realResponse ; } The calls the target, then mutates the response object, returning the mutated response. Modifying the request before proxying, then modifying the response 'POST /api/{path*}' : async ( req , h , proxy ) => { // Edit the request URL before proxying // (req.params is an object containing the path params, in this case `path`) req . url . pathname = '/api/v1/' + req . params . path ; // `req.payload` is the POST request payload (when JSON). Altering the object alters what gets proxied // You can also access `req.textPayload` to alter it as a string, or `req.rawPayload` to alter it as a buffer. // Whichever property is set last takes precedence - for instance, setting `req.textPayload = 'replaced'` after this // will overwrite the paylod with the string `replaced` req . payload . apiVersion = 2 ; // Edit the request headers before proxying // Incoming request headers are all lowercased req . headers [ 'x-replaced-header' ] = 'new or updated value' ; // Actually proxy the request const res = await proxy (); // Edit the response headers after proxying res . headers [ 'x-response-header' ] = 'new or updated value' ; // Return the response return res ; }, Construct a custom response 'PUT /api/mockme' : ( req , h , proxy ) => { // Return a custom response with a custom status code and headers // assuming called with `?arg=xxxx` const result = { some : { json : 4 , queryArg : req . url . query . arg } }; // The `h` variable is the Hapi response toolkit const response = h . response ( result ); response . header ( 'x-response-header' , 'new value' ); response . code ( 202 ); response . type ( 'application/json' ); return response ; }","title":"Example route configurations"},{"location":"guide/certificates/","text":"HTTPS TLS certificates are automatically generated, signed, and trusted (for Chrome / Safari) when required. They are valid for 7 days and stored in ~/.dev-ssl-certs. If when starting a proxy there is less than 24 hours validity left, the certificate is untrusted, deleted and re-created with another 7 days validity. The command generate-cert allows for generating a self-signed cert. The certificate and key are generated in the current directory and is NOT automatically trusted. e.g. intervene generate-cert local.mycompany.test --notafter 2019-10-23 creates a certificate that is valid from 1 hour ago until 23rd October 2019, for the domain local.mycompany.test.","title":"Certificates & HTTPS"},{"location":"guide/debugging/","text":"You can use a normal console.log etc from your configs (since 2.2.0), but also you can simply import the log function from the package and use either the log function directly or the helper methods. e.g. import { ProxyConfig , log } from 'intervene' ; const config : ProxyConfig = { target : 'https://api.mycompany.com' , routes : { '/foo' : ( req , h , proxy ) => { log . debug ( '/foo was called' ); return { logged : true }; }, '/bar' : ( req , h , proxy ) => { // This uses the log call directly. You need to pass tags of the level, but can also pass other tags if other loggers are configured // (Which isn't yet possible through the command line interface, but might be implemented at some point) log ({ tags : [ 'info' ], message : '/bar was called' , data : { url : req . url }}); } } }; export default config ; log contains methods debug , info , warn and error methods, all taking a string and optional object with more information.","title":"Logging and Debugging"},{"location":"guide/delaying-responses/","text":"To slow down a response, you could return a promise from a handler that resolves only after a given delay, but it's such a common thing to do, intervene exports a helper makes this easy. Just import { delay } from 'intervene'; and wrap your handler or response with delay(msDelay, response) , where msDelay is the millisecond delay you want, and response is either the JSON or plain text response or the handler. Example \ud83d\udd17 import { ProxyConfig , delay } from 'intervene' ; const config : ProxyConfig = { target : 'https://api.myserver.com' , routes : { '/cats/123' : delay ( 1500 , { name : 'tiddles' , age : 7 }) } }","title":"Delaying / slowing down responses"},{"location":"guide/delaying-responses/#example","text":"import { ProxyConfig , delay } from 'intervene' ; const config : ProxyConfig = { target : 'https://api.myserver.com' , routes : { '/cats/123' : delay ( 1500 , { name : 'tiddles' , age : 7 }) } }","title":"Example"},{"location":"guide/faq/","text":"Why can I not import other modules into my config file? \ud83d\udd17 Because the file is transpiled \"live\" in a sandboxed environment, we can't (yet) support loading external modules, other than native node modules. It won't start / has errors? \ud83d\udd17 Double check that there isn't another instance running. intervene starts a second privileged process to perform administrative actions (such as writing to /etc/hosts), which it tries to shutdown when the main process ends. This isn't always successful (for instance if the main process is terminated with a SIGTERM signal).","title":"F.A.Q."},{"location":"guide/faq/#why-can-i-not-import-other-modules-into-my-config-file","text":"Because the file is transpiled \"live\" in a sandboxed environment, we can't (yet) support loading external modules, other than native node modules.","title":"Why can I not import other modules into my config file?"},{"location":"guide/faq/#it-wont-start-has-errors","text":"Double check that there isn't another instance running. intervene starts a second privileged process to perform administrative actions (such as writing to /etc/hosts), which it tries to shutdown when the main process ends. This isn't always successful (for instance if the main process is terminated with a SIGTERM signal).","title":"It won't start / has errors?"},{"location":"guide/making-requests/","text":"If you want to make a request to somewhere other than the target as part of a handler, for instance to call a configuration server to identify which endpoint to proxy to, you can import httpRequest from intervene The response is a promise, resulting in the same shape as when calling proxy() from a route handler. Note that you can change the host of the url as part of the request before you proxy, so if you only need to change the host dynamically, you can do that directly in the handler. httpRequest({ requestParams }) \ud83d\udd17 A function that makes an HTTP request. The response object is the same type as the proxy() method, so the response can be returned directly or modified and then returned. Obviously it's also possible to make a request and then return some other response as usual. Request parameters are defined as: method?: | 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'CONNECT'; url: string; headers?: { [key: string]: string | string[] | undefined }; hostname?: string; payload?: Buffer; rejectUnauthorized?: boolean;","title":"3rd party requests"},{"location":"guide/making-requests/#httprequest-requestparams","text":"A function that makes an HTTP request. The response object is the same type as the proxy() method, so the response can be returned directly or modified and then returned. Obviously it's also possible to make a request and then return some other response as usual. Request parameters are defined as: method?: | 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'CONNECT'; url: string; headers?: { [key: string]: string | string[] | undefined }; hostname?: string; payload?: Buffer; rejectUnauthorized?: boolean;","title":"httpRequest({ requestParams })"},{"location":"guide/typed-routes/","text":"You may want to use intervene to have a discussion around the data exchange format between backend and client (whilst mocking the backend so that the client can be built). To do this, you may want to describe the shape of the request and/or the response. Enter routeBuilder \ud83d\udd17 You can import routeBuilder in the same way from the project. It is a function which takes up to 3 type parameters, RequestT , ResponseT and ProxyResponseT , and a single argument of either the response or the response handler function (so everything you can put against a route). Examples: import { ProxyConfig , routeBuilder } from 'intervene' ; interface NewTweet { text : string ; source : 'web' | 'android' | 'ios' ; } // A CreatedTweet is the same as a NewTweet, but with an id interface CreatedTweet extends NewTweet { id : string ; } // A BackendTweet is the same as a CreatedTweet, but with uid as a number // (Scenario here is to change a frontend to use `id` as a string instead of `uid` as a number) interface BackendTweet extends NewTweet { uid : number ; } const config : ProxyConfig = { target : 'https://api.mycompany.com' , routes : { // This describes the request POST body format as a `NewPlaylist` type. // Note that this has no effect as we're always returning a static response // However, it serves as documentation for what the request body should look like 'POST /tweet' : routeBuilder < NewTweet > ({ id : 'tweets:9999999999999' }), 'POST /tweet2' : routeBuilder < NewTweet > (( req , h , proxy ) => { // Here, because this is a handler method, we have typed access to the request properties return { id : 'tweets:9999999999999' , text : req.payload.text , // <-- all the autocomplete goodness here :) source : req.payload.source }; }), // Here we're defining a response type too. We'll get errors in the console when we save the config if the response // deviates from what is defined 'POST /tweet3' : routeBuilder < NewTweet , CreatedTweet > (( req , h , proxy ) => { return { id : 'tweets:999999999999999' , text : req.payload.text , // <-- all the autocomplete goodness here :) source : req.payload.source }; }), // Here we're just defining the response type. We'll get typescript errors if the // response deviates from the type. This can be useful if you're using the types to // form the discussion and documentation around the data exchange formats, and you // don't want to be returning something that isn't valid. 'GET /tweets/999999' : routeBuilder < never , CreatedTweet > ({ id : 'tweets:999999' , text : 'foo' , source : 'web' }) // Here we're calling the real backend with the `proxy()` function, and mapping that type // This is useful if you're altering the backend response in some way, but want typed access // to both. The default type for the proxy response is the same as the ResponseT, so you only // need this if you are changing the shape of the data as it passes through intervene 'GET /tweets/777777' : routeBuilder < never , CreatedTweet , BackendTweet > ( async ( req , h , proxy ) => { const response = await proxy (); // response is of type BackendPlaylist return { id : 'tweets:' + ( response . body . uid * 10 ), text : response.body.text , source : response.body.source }; }) } }","title":"Typed routes"},{"location":"guide/typed-routes/#enter-routebuilder","text":"You can import routeBuilder in the same way from the project. It is a function which takes up to 3 type parameters, RequestT , ResponseT and ProxyResponseT , and a single argument of either the response or the response handler function (so everything you can put against a route). Examples: import { ProxyConfig , routeBuilder } from 'intervene' ; interface NewTweet { text : string ; source : 'web' | 'android' | 'ios' ; } // A CreatedTweet is the same as a NewTweet, but with an id interface CreatedTweet extends NewTweet { id : string ; } // A BackendTweet is the same as a CreatedTweet, but with uid as a number // (Scenario here is to change a frontend to use `id` as a string instead of `uid` as a number) interface BackendTweet extends NewTweet { uid : number ; } const config : ProxyConfig = { target : 'https://api.mycompany.com' , routes : { // This describes the request POST body format as a `NewPlaylist` type. // Note that this has no effect as we're always returning a static response // However, it serves as documentation for what the request body should look like 'POST /tweet' : routeBuilder < NewTweet > ({ id : 'tweets:9999999999999' }), 'POST /tweet2' : routeBuilder < NewTweet > (( req , h , proxy ) => { // Here, because this is a handler method, we have typed access to the request properties return { id : 'tweets:9999999999999' , text : req.payload.text , // <-- all the autocomplete goodness here :) source : req.payload.source }; }), // Here we're defining a response type too. We'll get errors in the console when we save the config if the response // deviates from what is defined 'POST /tweet3' : routeBuilder < NewTweet , CreatedTweet > (( req , h , proxy ) => { return { id : 'tweets:999999999999999' , text : req.payload.text , // <-- all the autocomplete goodness here :) source : req.payload.source }; }), // Here we're just defining the response type. We'll get typescript errors if the // response deviates from the type. This can be useful if you're using the types to // form the discussion and documentation around the data exchange formats, and you // don't want to be returning something that isn't valid. 'GET /tweets/999999' : routeBuilder < never , CreatedTweet > ({ id : 'tweets:999999' , text : 'foo' , source : 'web' }) // Here we're calling the real backend with the `proxy()` function, and mapping that type // This is useful if you're altering the backend response in some way, but want typed access // to both. The default type for the proxy response is the same as the ResponseT, so you only // need this if you are changing the shape of the data as it passes through intervene 'GET /tweets/777777' : routeBuilder < never , CreatedTweet , BackendTweet > ( async ( req , h , proxy ) => { const response = await proxy (); // response is of type BackendPlaylist return { id : 'tweets:' + ( response . body . uid * 10 ), text : response.body.text , source : response.body.source }; }) } }","title":"Enter routeBuilder"},{"location":"guide/usage/","text":"Intervene has a handful of commands that each take options: create <url> : Create and start a new proxy \ud83d\udd17 Create a proxy to api.mycompany.com intervene create https://api.mycompany.com -e This creates a sample config file (called api.mycompany.com.ts), and opens the file in your editor ( TS_EDITOR , VISUAL or EDITOR environment variables - it's advisable that these are not console editors, as the console is also used for logging from the proxy). If your editor has typescript support, you'll get autocompletion and documentation when editing the config. The proxy is automatically started. If this is a HTTPS target, a self-signed certificate is generated and trusted as part of the startup process. The import statement is generated from the absolute location of the module, which might be in your /usr/local/lib/node_modules directory if you've installed intervene globally. This is actually less of a problem that it seems (especially when sharing configurations, for instance by checking them in to your repo), as the path for the import is automatically patched when starting the proxy. For instance, even if the import is import { ProxyConfig } from '/foo/bar/intervene'; , it will still work even though /foo/bar doesn't exist, because the path gets patched to the path of the current intervene module before the file is imported. Saving the config file automatically reloads it and reconfigures the proxy. start <config-path> : Start a proxy from a given config file \ud83d\udd17 To start a proxy with a given config file: intervene start my-config.ts It's also possible to use config files from HTTP(s) locations, intervene start https://gist.mycompany.com/raw/myconfig.ts generate-cert <hostname> : Generate a self signed certificate \ud83d\udd17 Generate a self signed certificate for use outside of intervene . There's very few options here, it just produces a valid certificate for a domain, which is easier than finding all the right options for openssl. Options: -a --notafter Date in ISO8601 ( YYYY-MM-DDTHH:MM:SSZ ) format the certificate should be valid until . Defaults to 7 days from the current date. -b --notbefore Date in ISO8601 ( YYYY-MM-DDTHH:MM:SSZ ) format the certificate should be valid form . Defaults to 1 hour ago. -f --filename Filename to write the certificate to (in PEM format). The key file will be the same file but with a .key extension. Defaults to <hostname>.pem","title":"Usage"},{"location":"guide/usage/#create-lturlgt-create-and-start-a-new-proxy","text":"Create a proxy to api.mycompany.com intervene create https://api.mycompany.com -e This creates a sample config file (called api.mycompany.com.ts), and opens the file in your editor ( TS_EDITOR , VISUAL or EDITOR environment variables - it's advisable that these are not console editors, as the console is also used for logging from the proxy). If your editor has typescript support, you'll get autocompletion and documentation when editing the config. The proxy is automatically started. If this is a HTTPS target, a self-signed certificate is generated and trusted as part of the startup process. The import statement is generated from the absolute location of the module, which might be in your /usr/local/lib/node_modules directory if you've installed intervene globally. This is actually less of a problem that it seems (especially when sharing configurations, for instance by checking them in to your repo), as the path for the import is automatically patched when starting the proxy. For instance, even if the import is import { ProxyConfig } from '/foo/bar/intervene'; , it will still work even though /foo/bar doesn't exist, because the path gets patched to the path of the current intervene module before the file is imported. Saving the config file automatically reloads it and reconfigures the proxy.","title":"create &amp;lt;url&amp;gt;: Create and start a new proxy"},{"location":"guide/usage/#start-ltconfig-pathgt-start-a-proxy-from-a-given-config-file","text":"To start a proxy with a given config file: intervene start my-config.ts It's also possible to use config files from HTTP(s) locations, intervene start https://gist.mycompany.com/raw/myconfig.ts","title":"start &amp;lt;config-path&amp;gt;: Start a proxy from a given config file"},{"location":"guide/usage/#generate-cert-lthostnamegt-generate-a-self-signed-certificate","text":"Generate a self signed certificate for use outside of intervene . There's very few options here, it just produces a valid certificate for a domain, which is easier than finding all the right options for openssl. Options: -a --notafter Date in ISO8601 ( YYYY-MM-DDTHH:MM:SSZ ) format the certificate should be valid until . Defaults to 7 days from the current date. -b --notbefore Date in ISO8601 ( YYYY-MM-DDTHH:MM:SSZ ) format the certificate should be valid form . Defaults to 1 hour ago. -f --filename Filename to write the certificate to (in PEM format). The key file will be the same file but with a .key extension. Defaults to <hostname>.pem","title":"generate-cert &amp;lt;hostname&amp;gt;: Generate a self signed certificate"},{"location":"reference/configuration/","text":"The configuration file is a TypeScript module which exports an object of type ProxyConfig . You can create a config file by running intervene create <URL> , which will create a sample config file, save it under the name of the host and start the proxy. e.g. intervene create https://api.mycompany.com Example configuration \ud83d\udd17 import { ProxyConfig } from '/usr/local/lib/node_modules/intervene' ; const config : ProxyConfig = { target : 'https://api.mycompany.com' }; export default config ; Configuration Options \ud83d\udd17 ProxyConfig has the following members (where only target is mandatory) target : The URL that should be proxied to. Note that paths here are not supported. localUrl : The local scheme, hostname and optionally port to listen on. If this is not present, the target is used as the localUrl targetHeaders : An object with headers to override when making proxy calls. Examples of headers that can be useful here are host and x-forwarded-proto . writeEtcHosts : Boolean. If this is true, /etc/hosts will be written to with the localUrl hostname or target hostname. Default true skipEtcHosts : Boolean. If this is true, /etc/hosts will not be used when looking up the IP address to connect to when proxying. This is the default, as it enables writing a public hostname to /etc/hosts (e.g. api.mycompany.com ) and then proxying to the real address. Default true . allowUntrustedCerts : Boolean. If this is true, when the target is HTTPS, targets are allowed to have untrusted or invalid certificates. Ensure this is true if the target is using a self-signed or custom CA signed certificate. Default is true . removeStrictTransportSecurity : Boolean. Removes the Strict-Transport-Security headers from any proxied request, meaning that browsers like Firefox that don't allow self-signed certs on sites with HSTS enabled can be worked around. Set this to false to leave Strict-Transport-Security headers in the response. Defaults to true . onShutdown : () => void | Promise<any> . A function which gets called when the proxy process is shutdown (i.e. with Ctrl-C). Use this if you need to clean anything up when shutting down. routes : An object with keys as paths to override (paths are hapi path parameters ). Optionally prefixed with the uppercase HTTP verb (defaults to GET ). Values are either JSON to return as application/json string to return as text/plain a function: (request, h, proxy) => Promise<response> request is the request information, which can be edited method - the HTTP request method url - the requested url, parsed into object form, including query string parsing headers - object containing the request headers payload - in the case of a PUT or POST , contains the payload (in JSON format if applicable) h is the hapi response toolkit , if you need to construct your own responses proxy is a function which returns a promise of the response from the target. If any of the properties of the request are altered before calling this method, the changes are used to make the request. The return value of the function can be any one of the following: A JavaScript object. This will be returned as an application/json response A response created from h.response(...) (see hapi response builder ) The (optionally altered) response object from calling proxy() (the third argument to the route function) A promise that resolves to any of the above values","title":"Configuration"},{"location":"reference/configuration/#example-configuration","text":"import { ProxyConfig } from '/usr/local/lib/node_modules/intervene' ; const config : ProxyConfig = { target : 'https://api.mycompany.com' }; export default config ;","title":"Example configuration"},{"location":"reference/configuration/#configuration-options","text":"ProxyConfig has the following members (where only target is mandatory) target : The URL that should be proxied to. Note that paths here are not supported. localUrl : The local scheme, hostname and optionally port to listen on. If this is not present, the target is used as the localUrl targetHeaders : An object with headers to override when making proxy calls. Examples of headers that can be useful here are host and x-forwarded-proto . writeEtcHosts : Boolean. If this is true, /etc/hosts will be written to with the localUrl hostname or target hostname. Default true skipEtcHosts : Boolean. If this is true, /etc/hosts will not be used when looking up the IP address to connect to when proxying. This is the default, as it enables writing a public hostname to /etc/hosts (e.g. api.mycompany.com ) and then proxying to the real address. Default true . allowUntrustedCerts : Boolean. If this is true, when the target is HTTPS, targets are allowed to have untrusted or invalid certificates. Ensure this is true if the target is using a self-signed or custom CA signed certificate. Default is true . removeStrictTransportSecurity : Boolean. Removes the Strict-Transport-Security headers from any proxied request, meaning that browsers like Firefox that don't allow self-signed certs on sites with HSTS enabled can be worked around. Set this to false to leave Strict-Transport-Security headers in the response. Defaults to true . onShutdown : () => void | Promise<any> . A function which gets called when the proxy process is shutdown (i.e. with Ctrl-C). Use this if you need to clean anything up when shutting down. routes : An object with keys as paths to override (paths are hapi path parameters ). Optionally prefixed with the uppercase HTTP verb (defaults to GET ). Values are either JSON to return as application/json string to return as text/plain a function: (request, h, proxy) => Promise<response> request is the request information, which can be edited method - the HTTP request method url - the requested url, parsed into object form, including query string parsing headers - object containing the request headers payload - in the case of a PUT or POST , contains the payload (in JSON format if applicable) h is the hapi response toolkit , if you need to construct your own responses proxy is a function which returns a promise of the response from the target. If any of the properties of the request are altered before calling this method, the changes are used to make the request. The return value of the function can be any one of the following: A JavaScript object. This will be returned as an application/json response A response created from h.response(...) (see hapi response builder ) The (optionally altered) response object from calling proxy() (the third argument to the route function) A promise that resolves to any of the above values","title":"Configuration Options"},{"location":"reference/route-handlers/","text":"Routes definitions can be: JSON to return as application/json a string to return as text/plain a function: (request, h, proxy) => Promise<response> request is the request information, which can be edited method - the HTTP request method url - the requested url, parsed into object form, including query string parsing headers - object containing the request headers payload - for PUT and POST , contains the payload in JSON format if applicable textPayload - for PUT and POST , contains the payload in string format rawPayload - for PUT and POST , contains the payload in Buffer format h is the hapi response toolkit , if you need to construct your own responses proxy is a function which returns a promise of the response from the target. If any of the properties of the request are altered before calling this method, the changes are used to make the request. The return value of the function can be any one of the following: A JavaScript object. This will be returned as an application/json response A response created from h.response(...) (see hapi response builder ) The (optionally altered) response object from calling proxy() (the third argument to the route function) A promise that resolves to any of the above values Change the HTTP method \ud83d\udd17 Set req.method to whichever method you need to proxy to. import { ProxyConfig } from 'intervene' ; const config : ProxyConfig = { target : 'https://api.mycompany.com' , routes : { // Change `POST /api/cats` to `PUT /api/cats` and forward to the server 'POST /api/cats' : ( req , h , proxy ) => { req . method = 'PUT' return proxy (); } } }; export default config ; Change URL properties \ud83d\udd17 req.url is the parsed URL of the target . This means you can update the host, path or anything else to update where the request will be proxied to. Properties to edit: host : the hostname (without port) port : the port to use (if not default for the protocol , otherwise null ) protocol : the protocol to use, followed by : . e.g. http: or https: pathname : the path (without the query) query : the parsed query string as an object import { ProxyConfig } from 'intervene' ; const config : ProxyConfig = { target : 'https://api.mycompany.com' , routes : { '/api/cats' : ( req , h , proxy ) => { // Change `GET /api/cats` to `GET /api/v2/cats` req . url . pathname = '/api/v2/cats' ; // update the query property, to add `?api_version=2` req . url . query . api_version = '2' ; return proxy (); } } }; export default config ; Response object \ud83d\udd17 The response object is returned from calls to proxy() and also calls to httpRequest contains the following properties body : A JavaScript object with the parsed JSON response (if content type is application/json ) text : < string | undefined > The response in string format. rawResponse : < Buffer > The response as a raw binary Buffer statusCode : < number > The HTTP status code of the response headers : < Array<string | string[] | undefined> > An object with key value pairs of the header values A route handler can return the response object directly, or modify it and return it. Setting text or rawResponse properties will override the response body - whichever is set last takes precedence. kk","title":"Route handlers"},{"location":"reference/route-handlers/#change-the-http-method","text":"Set req.method to whichever method you need to proxy to. import { ProxyConfig } from 'intervene' ; const config : ProxyConfig = { target : 'https://api.mycompany.com' , routes : { // Change `POST /api/cats` to `PUT /api/cats` and forward to the server 'POST /api/cats' : ( req , h , proxy ) => { req . method = 'PUT' return proxy (); } } }; export default config ;","title":"Change the HTTP method"},{"location":"reference/route-handlers/#change-url-properties","text":"req.url is the parsed URL of the target . This means you can update the host, path or anything else to update where the request will be proxied to. Properties to edit: host : the hostname (without port) port : the port to use (if not default for the protocol , otherwise null ) protocol : the protocol to use, followed by : . e.g. http: or https: pathname : the path (without the query) query : the parsed query string as an object import { ProxyConfig } from 'intervene' ; const config : ProxyConfig = { target : 'https://api.mycompany.com' , routes : { '/api/cats' : ( req , h , proxy ) => { // Change `GET /api/cats` to `GET /api/v2/cats` req . url . pathname = '/api/v2/cats' ; // update the query property, to add `?api_version=2` req . url . query . api_version = '2' ; return proxy (); } } }; export default config ;","title":"Change URL properties"},{"location":"reference/route-handlers/#response-object","text":"The response object is returned from calls to proxy() and also calls to httpRequest contains the following properties body : A JavaScript object with the parsed JSON response (if content type is application/json ) text : < string | undefined > The response in string format. rawResponse : < Buffer > The response as a raw binary Buffer statusCode : < number > The HTTP status code of the response headers : < Array<string | string[] | undefined> > An object with key value pairs of the header values A route handler can return the response object directly, or modify it and return it. Setting text or rawResponse properties will override the response body - whichever is set last takes precedence. kk","title":"Response object"}]}